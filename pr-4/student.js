const { EventEmitter } = require('events');
const Student = require('./models/Student');
const { BackupManager } = require('./backup-manager');

const studentEvents = new EventEmitter();
let backupManager = null;

async function loadStudents() {
  try {
    // For database, we don't need to "load" - data is already in DB
    // This function is kept for compatibility with existing code
    const students = await Student.findAll();
    studentEvents.emit('students:loaded', students);
    return students;
  } catch (error) {
    studentEvents.emit('students:load:error', error);
    throw error;
  }
}

async function saveStudents() {
  try {
    // For database, save is not needed as changes are persisted immediately
    // This function is kept for compatibility with existing code
    const students = await Student.findAll();
    studentEvents.emit('students:saved', students);
    return students;
  } catch (error) {
    studentEvents.emit('students:save:error', error);
    throw error;
  }
}

async function addStudent(name, age, group) {
  try {
    const student = await Student.create({
      name: name.trim(),
      age,
      group,
    });
    studentEvents.emit('student:added', student);
    return student;
  } catch (error) {
    studentEvents.emit('student:add:error', error);
    throw error;
  }
}

async function removeStudent(id) {
  try {
    const student = await Student.findByPk(id);
    if (student) {
      await student.destroy();
      studentEvents.emit('student:removed', student);
      return student;
    }
    studentEvents.emit('student:remove:notfound', id);
    return null;
  } catch (error) {
    studentEvents.emit('student:remove:error', error);
    throw error;
  }
}

async function getStudentById(id) {
  try {
    const student = await Student.findByPk(id);
    studentEvents.emit('student:retrieved', student, id);
    return student;
  } catch (error) {
    studentEvents.emit('student:retrieve:error', error);
    throw error;
  }
}

async function getStudentsByGroup(group) {
  try {
    const students = await Student.findAll({
      where: { group },
    });
    studentEvents.emit('students:filtered', students, group);
    return students;
  } catch (error) {
    studentEvents.emit('students:filter:error', error);
    throw error;
  }
}

async function getAllStudents() {
  try {
    const students = await Student.findAll({
      order: [['id', 'ASC']],
    });
    studentEvents.emit('students:retrieved', students);
    return students;
  } catch (error) {
    studentEvents.emit('students:retrieve:error', error);
    throw error;
  }
}

function startBackupManager(intervalMs = 30000) {
  if (backupManager === null) {
    backupManager = new BackupManager(getAllStudents, intervalMs);
    backupManager.start();
  }
  return backupManager;
}

function getBackupManager() {
  return backupManager;
}

function stopBackupManager() {
  if (backupManager !== null) {
    backupManager.stop();
  }
}

async function calculateAverageAge() {
  try {
    const students = await getAllStudents();
    let averageAge = 0;
    if (students.length > 0) {
      const totalAge = students.reduce((sum, s) => sum + s.age, 0);
      averageAge = totalAge / students.length;
    }
    studentEvents.emit('average:calculated', averageAge);
    return averageAge;
  } catch (error) {
    studentEvents.emit('average:calculate:error', error);
    throw error;
  }
}

async function updateStudent(id, name, age, group) {
  try {
    const student = await Student.findByPk(id);
    if (student) {
      student.name = name.trim();
      student.age = age;
      student.group = group;
      await student.save();
      studentEvents.emit('student:updated', student);
      return student;
    }
    studentEvents.emit('student:update:notfound', id);
    return null;
  } catch (error) {
    studentEvents.emit('student:update:error', error);
    throw error;
  }
}

async function replaceAllStudents(newStudents) {
  try {
    if (!Array.isArray(newStudents)) {
      throw new Error('Students must be an array');
    }

    // Validate all students have required fields (id is optional as DB will auto-generate)
    for (const student of newStudents) {
      if (!student.name || student.age === undefined || student.group === undefined) {
        throw new Error('All students must have name, age, and group');
      }
    }

    // Use transaction to ensure all-or-nothing replacement
    const { sequelize } = require('./config/database');
    const transaction = await sequelize.transaction();

    try {
      // Delete all existing students
      await Student.destroy({ where: {}, transaction });

      // Insert new students (IDs will be auto-generated by database)
      const studentsToCreate = newStudents.map((s) => ({
        name: s.name.trim(),
        age: s.age,
        group: s.group,
      }));

      await Student.bulkCreate(studentsToCreate, { transaction });

      await transaction.commit();

      const students = await getAllStudents();
      studentEvents.emit('students:replaced', students);
      return students;
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  } catch (error) {
    studentEvents.emit('students:replace:error', error);
    throw error;
  }
}

module.exports = {
  Student,
  addStudent,
  removeStudent,
  updateStudent,
  getStudentById,
  getStudentsByGroup,
  getAllStudents,
  calculateAverageAge,
  loadStudents,
  saveStudents,
  replaceAllStudents,
  startBackupManager,
  stopBackupManager,
  getBackupManager,
  studentEvents,
};
